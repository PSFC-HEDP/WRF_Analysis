__author__ = 'Alex Zylstra'

import numpy
import csv
import os

def float_perc(str_in):
    """Convert a string to float with correction for percent symbols.
        i.e. 10% converts to 0.1."""
    assert isinstance(str_in,str)

    str_in = str_in.replace('%','e-2')

    return float(str_in)


class WRF_CSV(object):
    """Wrapper object for initial WRF analysis files. Reads in the CSV file generated by
    Fredrick's program, which is then parsed into the class variables."""

    def __init__(self, fname, crop=True):
        """
        Initialize the class and parse the file.
        :param fname: The filename to parse, as str
        :param crop: (optional) if zero (i.e. non-informative) points should be removed from the spectrum [default=True]
        """
        super(WRF_CSV, self).__init__()

        # initializations for all variables
        # File name for the input
        self.fname = ""
        # Date the analysis was done:
        self.date = ""
        # Shot that the WRF was used on:
        self.shot = ""
        # DIM that the WRF was used on:
        self.dim = ""
        # position within the DIM:
        self.pos = ""
        # Time the analysis was done:
        self.time = ""
        # Program version date:
        self.program_date = ""
        # Scan file name:
        self.scan_file = ""
        # WRF port
        self.port = ""
        # WRF distance (cm)
        self.distance = 0
        # WRF ID
        self.WRF_ID = ""
        # CR-39 serial number
        self.CR39_ID = ""
        # Blast filter thickness:
        self.Al_Blast_Filter = 0
        # Calibration info:
        self.WRF_Cal = ""
        # Data region limits:
        self.Data_Limits = (-1,-1,-1,-1)
        # Background #1 limits:
        self.BG1_Limits = (-1,-1,-1,-1)
        # Background #2 limits:
        self.BG2_Limits = (-1,-1,-1,-1)
        # contrast limit
        self.Contrast_Limit = 0
        # eccentricity limit
        self.Ecc_Limit = 0
        # Dmax chosen in the analysis
        self.Dmax = 0
        self.Dmax_Unc = 0
        self.Dscale = 'new'
        # TODO: incorporate Dmax in database
        # Diameter limits:
        self.Dia_Limits = (-1,-1)
        # Whether diameter limits were chosen automatically
        self.Dia_Auto = False
        # Energy limits corresponding to the diameter limits
        self.E_Limits = (-1,-1)
        # DvE c parameter
        self.c = 0
        # Uncertainty in c parameter
        self.dc = 0
        # Chi^2 from fit
        self.chi2 = 0
        # energy limits used for the fit
        self.Fit_Limits = (-1,-1)
        # Fit values (E,sigma,Yield)
        self.Fit = (-1,-1,-1)
        # Random uncertainties in the fit values (dE,ds,dY)
        self.Unc_Random = (-1,-1,-1)
        # Systematic uncertainties in the fit values (dE,ds,dY)
        self.Unc_Systematic = (-1,-1,-1)
        # CountingStats uncertainties in the fit values (dE,ds,dY)
        self.Unc_CountingStats = (-1,-1,-1)
        # DvE uncertainties in the fit values (dE,ds,dY)
        self.Unc_DvE = (-1,-1,-1)
        # "Fit error scaling" (dE,ds,dY)
        self.Unc_FitError = (-1,-1,-1)
        # Dmax uncertainties in the fit values (dE,ds,dY)
        self.Unc_Dmax = (-1,-1,-1)
        # EtchScan uncertainties in the fit values (dE,ds,dY)
        self.Unc_EtchScan = (-1,-1,-1)
        # Nonlinearity uncertainties in the fit values (dE,ds,dY)
        self.Unc_Nonlinearity = (-1,-1,-1)
        # CalProc uncertainties in the fit values (dE,ds,dY)
        self.Unc_CalProc = (-1,-1,-1)

        # Spectrum data:
        self.spectrum = []

        # set the file name appropriately:
        self.fname = fname

        # try to determine shot/dim/pos from the file name:
        fname_sub = os.path.split(fname)[-1]  # get rid of leading folders from file name
        fname_components = fname_sub.split('_')

        # loop over:
        for part in fname_components:
            # check for the shot # as start:
            if part.startswith('N'):
                self.shot = part

            # check for positions:
            if part.startswith('PolPos'): # polar DIM
                print('polar DIM')
                self.dim = '0-0'
                self.pos = part[-1]
            elif part.startswith('Pos'): # equatorial DIM
                self.dim = '90-78'
                self.pos = part[-1]


        # open file:
        fileReader = csv.reader(open(fname,'r'),delimiter=',')

        # read in the data from file:
        fileData = []
        for row in fileReader:
            fileData.append(row)

        # Parse the meta data:
        for row in fileData:
            if len(row) > 0:
                if 'Date & time' in row[0] and len(row) >= 3:
                    self.date = row[1].strip()
                    self.time = row[2].strip()
                if 'Program version' in row[0] and len(row) >=2:
                    self.program_date = row[1].strip()
                if 'Scan file' in row[0] and len(row) >= 2:
                    self.scan_file = row[1].strip()
                if 'Port & distance' in row[0]  and len(row) >=3:
                    self.port = row[1].strip()
                    self.distance = float(row[2])
                if 'WRF ID; Al blast(um) & cal' in row[0] and len(row) >=4:
                    self.WRF_ID = row[1].strip()
                    self.Al_Blast_Filter = float(row[2])
                    self.WRF_Cal = row[3].strip()
                # Data region. Handle both 'old' and 'new' style WRF CSV files:
                if 'Data x0; x1; y0; y1' in row[0] and len(row) >=5:
                    xmin = float(row[1])
                    xmax = float(row[2])
                    ymin = float(row[3])
                    ymax = float(row[4])
                    self.Data_Limits = (xmin,xmax,ymin,ymax)
                elif 'Data ixlims; iylims' in row[0] and len(row) >=5:
                    # Remove parens and then split into indices:
                    xlim = row[1].replace('(','').replace(')','').split('-')
                    ylim = row[2].replace('(','').replace(')','').split('-')
                    # Set the limits:
                    self.Data_Limits = (float(xlim[0]), float(xlim[1]), float(ylim[0]), float(ylim[1]))
                if 'Back x0; x1; y0; y1' in row[0] and len(row) >=5 and self.BG1_Limits==(-1,-1,-1,-1):
                    xmin = float(row[1])
                    xmax = float(row[2])
                    ymin = float(row[3])
                    ymax = float(row[4])
                    self.BG1_Limits = (xmin,xmax,ymin,ymax)
                elif 'Back x0; x1; y0; y1' in row[0] and len(row) >=5:
                    xmin = float(row[1])
                    xmax = float(row[2])
                    ymin = float(row[3])
                    ymax = float(row[4])
                    self.BG2_Limits = (xmin,xmax,ymin,ymax)
                if 'C; e; Dmax' in row[0] and len(row) >= 6:
                    self.Contrast_Limit = float(row[1])
                    self.Ecc_Limit = float(row[2])
                    self.Dmax = float(row[3])
                    self.Dmax_Unc = float(row[4])
                    self.Dscale = row[5]
                if 'Dlow; Dhigh; Dauto; Elims' in row[0] and len(row) >=4:
                    self.Dia_Limits = (float(row[1]),float(row[2]))
                    if 'yes' in row[3] or 'Yes' in row[3] or 'true' in row[3] or 'True' in row[3]:
                        self.Dia_Auto = True
                    else:
                        self.Dia_Auto = False
                    if len(row) >= 6:
                        self.E_Limits = (float(row[4]),float(row[5]))
                if 'DvE fit: c; dc; red. Chi^2' in row[0] and len(row) >= 4:
                    self.c = float(row[1])
                    self.dc = float(row[2])
                    self.chi2 = float(row[3])
                if 'Fit limits' in row[0] and len(row) >= 3:
                    self.Fit_Limits = (float(row[1]),float(row[2]))
                if ('Value:' in row[0] or 'Value (gaussian fit):' in row[0]) and len(row) >= 4:
                    self.Fit = (float(row[1]),float(row[2]),float(row[3]))
                if '    Random:' in row[0] and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_Random = (dE,ds,dY)
                if '    Systematic calib:' in row[0] and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_Systematic = (dE,ds,dY)
                if ('     Counting statistics' in row[0] or '     Counting & fit:' in row[0]) and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_CountingStats = (dE,ds,dY)
                if ('     DvE fit:' in row[0] or '     DvE:' in row[0]) and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_DvE = (dE,ds,dY)
                if '     Fit error scaling:' in row[0] and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_FitError = (dE,ds,dY)
                if ('     Dmax scaling' in row[0] or '     Dmax:' in row[0]) and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_Dmax = (dE,ds,dY)
                if '     Etch & scan' in row[0] and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_EtchScan = (dE,ds,dY)
                if '     WRF nonlinearity' in row[0] and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_Nonlinearity = (dE,ds,dY)
                if ('     Cal. processing' in row[0] or '     Cal. & processing:' in row[0]) and len(row) >= 4:
                    dE = float(row[1])
                    ds = float(row[2])
                    # deal with converting %:
                    dY = float_perc(row[3].strip()) * self.Fit[2]
                    self.Unc_CalProc = (dE,ds,dY)

        # now go back to the filename to extract the CR39 ID #
        for part in fname_components:
            if part.startswith('134') or part.startswith('135'):  # look for CR39 IDs
                if not(part in self.WRF_ID):  # rule out the wedge ID, which is also in file name
                    self.CR39_ID = part

        # Parse the spectrum:
        self.spectrum = []
        spectrum_index = 0;
        for i in range(len(fileData)):
            if 'PROTON SPECTRUM' in fileData[i]:
                spectrum_index = i
        spectrum_index += 2 # now this is the first row of spectral data
        for i in range(spectrum_index,len(fileData)):
            if len(fileData[i]) > 0:
                line = fileData[i][0].split(sep='\t')
                E = float(line[0]) # Energy
                Y = float(line[1]) # Yield
                dY = float(line[2]) # Error

                # check:
                if crop:
                    if Y != 0 or dY != 0:
                        self.spectrum.append([E, Y, dY])
                else:
                    self.spectrum.append([E, Y, dY])

    def Print(self):
        info = "=== Metadata ===\n"
        info += "Shot: " + self.shot + '\n'
        info += "DIM: " + self.dim + '\n'
        info += "Pos: " + self.pos + '\n'
        info += "Date: " + self.date + '\n'
        info += "Time: " + self.time + '\n'
        info += "Program version: " + self.program_date + '\n'
        info += "Scan file: " + self.scan_file + '\n'
        info += "Port: " + self.port + '\n'
        info += "Distance: " + str(self.distance) + '\n'
        info += "WRF ID: " + self.WRF_ID + '\n'
        info += "Al blast filter: " + str(self.Al_Blast_Filter) + '\n'
        info += "WRF Cal: " + self.WRF_Cal + '\n'
        info += "Data limits: "
        for x in self.Data_Limits:
            info += str(x) + ','
        info += '\n'
        info += "Background 1: "
        for x in self.BG1_Limits:
            info += str(x) + ','
        info += '\n'
        info += "Background 2: "
        for x in self.BG2_Limits:
            info += str(x) + ','
        info += '\n'
        info += "Dia limits: " + str(self.Dia_Limits[0]) + ',' + str(self.Dia_Limits[1]) + '\n'
        info += "Auto dia: " + str(self.Dia_Auto) + '\n'
        info += "Energy limits: " + str(self.E_Limits[0]) + ',' + str(self.E_Limits[1]) + '\n'
        info += "C parameter = " + str(self.c) + " +/- " + str(self.dc) + " [chi^2 = " + str(self.chi2) + "]\n"
        info += "Fit limits: " + str(self.Fit_Limits[0]) + " - " + str(self.Fit_Limits[1]) + '\n'
        info += "Fit: "
        for x in self.Fit:
            info += str(x) + ','
        info += '\n'
        info += "Ran unc: "
        for x in self.Unc_Random:
            info += str(x) + ','
        info += '\n'
        info += "Sys unc: "
        for x in self.Unc_Systematic:
            info += str(x) + ','
        info += '\n'

        info += "=== Spectrum ===\n"
        for x in self.spectrum:
            info += str(x[0]) + ',' + str(x[1]) + ',' + str(x[2]) + '\n'


        print(info)
